#!/usr/bin/env node
/**
 * Build script for Clean Infinite Ask
 * 
 * Usage:
 *   node scripts/build.js dev    - Build dev version (infinite_ask_dev)
 *   node scripts/build.js prod   - Build production version (infinite_ask)
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const mode = process.argv[2] || 'dev';
const isDev = mode === 'dev';

const ROOT = path.join(__dirname, '..');
const PACKAGE_JSON = path.join(ROOT, 'package.json');
const CONFIG_FILE = path.join(ROOT, 'src', 'config.ts');

console.log(`\nüî® Building ${isDev ? 'DEV' : 'PROD'} version...\n`);

// 1. Read original package.json
const pkg = JSON.parse(fs.readFileSync(PACKAGE_JSON, 'utf8'));
const originalName = 'clean-infinite-ask';
const originalDisplayName = 'Clean Infinite Ask';

// 2. Modify package.json for dev/prod
if (isDev) {
    pkg.name = 'clean-infinite-ask-dev';
    pkg.displayName = 'Clean Infinite Ask (DEV)';
    pkg.version = pkg.version.includes('-dev') ? pkg.version : pkg.version + '-dev';
} else {
    pkg.name = originalName;
    pkg.displayName = originalDisplayName;
    pkg.version = pkg.version.replace(/-dev$/, '');
}

// Update command names to avoid conflicts
const cmdPrefix = isDev ? 'cleanInfiniteAskDev' : 'cleanInfiniteAsk';
const titlePrefix = isDev ? 'Clean Infinite Ask DEV' : 'Clean Infinite Ask';

pkg.contributes.commands = [
    {
        command: `${cmdPrefix}.configure`,
        title: `${titlePrefix}: Configure Now`
    },
    {
        command: `${cmdPrefix}.test`,
        title: `${titlePrefix}: Test Dialog`
    }
];

// 3. Write config.ts with build-time constants
const configContent = `/**
 * Auto-generated build configuration
 * DO NOT EDIT MANUALLY - Generated by scripts/build.js
 */

export const BUILD_CONFIG = {
    isDev: ${isDev},
    mcpServerName: '${isDev ? 'infinite_ask_dev' : 'infinite_ask'}',
    ipcPort: ${isDev ? 19824 : 19823},
    displayName: '${isDev ? 'Infinite Ask (DEV)' : 'Infinite Ask'}',
    version: '${pkg.version}'
};
`;

fs.writeFileSync(CONFIG_FILE, configContent, 'utf8');
console.log(`‚úÖ Generated config.ts (isDev=${isDev})`);

// 4. Write modified package.json
fs.writeFileSync(PACKAGE_JSON, JSON.stringify(pkg, null, 4), 'utf8');
console.log(`‚úÖ Updated package.json (name=${pkg.name}, version=${pkg.version})`);

// 5. Update MCP server with build config
const mcpServerPath = path.join(ROOT, 'assets', 'mcp-server', 'index.js');
let mcpContent = fs.readFileSync(mcpServerPath, 'utf8');

// Replace IPC_PORT
mcpContent = mcpContent.replace(
    /const IPC_PORT = \d+;/,
    `const IPC_PORT = ${isDev ? 19824 : 19823};`
);

// Replace VERSION
mcpContent = mcpContent.replace(
    /const VERSION = '[^']+';/,
    `const VERSION = '${pkg.version}';`
);

fs.writeFileSync(mcpServerPath, mcpContent, 'utf8');
console.log(`‚úÖ Updated MCP server (port=${isDev ? 19824 : 19823})`);

// 6. Compile TypeScript
console.log('\nüì¶ Compiling TypeScript...');
try {
    execSync('npm run compile', { cwd: ROOT, stdio: 'inherit' });
    console.log('‚úÖ Compilation successful\n');
} catch (e) {
    console.error('‚ùå Compilation failed');
    process.exit(1);
}

// 7. Output summary
console.log('‚ïê'.repeat(50));
console.log(`üìã Build Summary:`);
console.log(`   Mode:       ${isDev ? 'DEVELOPMENT' : 'PRODUCTION'}`);
console.log(`   Name:       ${pkg.name}`);
console.log(`   Version:    ${pkg.version}`);
console.log(`   MCP Name:   ${isDev ? 'infinite_ask_dev' : 'infinite_ask'}`);
console.log(`   IPC Port:   ${isDev ? 19824 : 19823}`);
console.log('‚ïê'.repeat(50));
console.log(`\nüéâ Build complete! To install:`);
console.log(`   1. Run: vsce package`);
console.log(`   2. Install the generated .vsix file in Windsurf\n`);
